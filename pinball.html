<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <title>Pinball Shooter – Boss, Space Restart</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: #0f0f12;
            color: #e8e8ea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: system-ui, sans-serif;
        }

        #wrap {
            width: 460px;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin: 6px 0 8px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        canvas {
            width: 460px;
            height: 720px;
            border: 1px solid #2c2f3a;
            background: #12141a;
        }

        #msg {
            text-align: center;
            margin-top: 8px;
            font-size: 14px;
            opacity: .8;
        }

        button {
            background: #1f6feb;
            color: #fff;
            border: 0;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
        }

        .hud-item {
            min-width: 120px;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <div id="hud">
            <div class="hud-item">점수: <span id="score">0</span></div>
            <div class="hud-item">HP: <span id="hp">3</span></div>
            <div class="hud-item">최대 볼: <span id="maxBalls">5</span></div>
            <div><button id="restart">다시 시작</button></div>
        </div>
        <canvas id="game" width="460" height="720"></canvas>
        <div id="msg">← → 이동, ↑ ↓ 각도, Space 자동발사 시작 · 게임오버 시 Space로 재시작</div>
    </div>

    <script>
        (() => {
            // ===== Canvas & State =====
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const hpEl = document.getElementById('hp');
            const maxBallsEl = document.getElementById('maxBalls');
            const restartBtn = document.getElementById('restart');

            const W = canvas.width;
            const H = canvas.height;

            // ===== Config =====
            const playerSize = 34; // 정사각형
            const player = { x: W / 2, y: H - 46, w: playerSize, h: playerSize, speed: 6 };

            const ballRadius = 6;
            let maxBalls = 5;
            const ballSpeed = 4.2;
            const fireIntervalMs = 140;

            const blockCols = 8;
            const leftPad = 20;
            const rightPad = 20;
            const blockGap = 6;
            const cell = Math.floor((W - leftPad - rightPad) / blockCols);
            const blockSize = cell - blockGap; // 일반 블록 정사각형

            const blockFallBase = 0.32;
            const blockFallGainPerSec = 0.0008; // 미세 가속

            const itemFallSpeed = 0.95;
            const dropChance = 0.03; // 낮춘 출현률

            const hpGrowthPerSec = 0.05; // 스폰 HP = 1 + rate * 경과초

            // 간격 보호
            const minBlockGap = 8; // 세로 최소 간격(px)

            // 보스 설정
            const bossSize = blockSize * 3;          // 정사각형 3배
            const bossHpMultiplier = 8;              // 보스 HP 배수
            const bossSpawnIntervalSec = 25;         // 주기(초)
            let lastBossSpawnTime = 0;               // 마지막 스폰 시각(ts ms)
            const bossDropRolls = 2;                 // 드랍 시도 횟수(아이템 0~2개)
            const bossFirstDelaySec = 10;   // 첫 보스 대기시간(초)
            let bossSpawnCount = 0;         // 지금까지 소환된 보스 수
            // 보스/일반 스폰 동결 창
            const preBossFreezeSec = 3;   // 보스 등장 전 일반 스폰 중단 시간
            const postBossFreezeSec = 2;  // 보스 등장 후 일반 스폰 재개까지 대기
            let normalSpawnPausedUntil = 0; // 이 시각 이전엔 일반 스폰 금지(ms)
            let bossPreFreezeUntil = 0;     // 보스 사전 동결 종료 시각(ms)

            const ITEM_TYPE = { MAX_BALL: 'MAX_BALL', DMG_UP: 'DMG_UP' };

            // ===== Runtime State =====
            let balls = [];
            let blocks = [];
            let items = [];
            let score = 0;
            let hp = 3;
            let gameOver = false;

            let ballDamageBase = 1.0; // 새로 발사되는 볼의 기본 데미지

            // 조준 각도
            let aimAngle = -Math.PI / 2;
            const minAngle = (-Math.PI / 2) - Math.PI / 4;
            const maxAngle = (-Math.PI / 2) + Math.PI / 4;

            // 입력
            let keyLeft = false;
            let keyRight = false;
            let keyUp = false;
            let keyDown = false;

            // 발사 제어
            let autoFire = false;
            let lastFireTime = 0;
            let lastSpawnTime = 0;

            // 시간
            let startEpoch = 0;
            let lastTs = 0;

            // ===== Utils =====
            const clamp = (v, min, max) => {
                if (v < min) { return min; }
                if (v > max) { return max; }
                return v;
            };

            const nowElapsedSec = (ts) => {
                if (startEpoch === 0) {
                    return 0;
                }
                return (ts - startEpoch) / 1000;
            };

            const updateMaxBallsUI = () => {
                maxBallsEl.textContent = String(maxBalls);
            };

            const updateHpUI = () => {
                hpEl.textContent = String(hp);
            };

            const rectsOverlapHoriz = (ax, aw, bx, bw) => {
                if (ax + aw <= bx) {
                    return false;
                }
                if (bx + bw <= ax) {
                    return false;
                }
                return true;
            };

            const hasVerticalClearance = (x, w, ySpawn, needClear) => {
                let topY = Infinity;
                for (let i = 0; i < blocks.length; i++) {
                    const b = blocks[i];
                    if (rectsOverlapHoriz(x, w, b.x, b.w) === true) {
                        if (b.y < topY) {
                            topY = b.y;
                        }
                    }
                }
                if (topY === Infinity) {
                    return true;
                }
                if ((topY - ySpawn) >= needClear) {
                    return true;
                }
                return false;
            };

            const resetGame = () => {
                balls = [];
                blocks = [];
                items = [];
                score = 0;
                hp = 3;
                gameOver = false;
                maxBalls = 5;
                ballDamageBase = 1.0;
                player.x = W / 2;
                aimAngle = -Math.PI / 2;
                autoFire = false;
                lastFireTime = 0;
                lastSpawnTime = 0;
                lastBossSpawnTime = 0;
                bossSpawnCount = 0;
                normalSpawnPausedUntil = 0;
                bossPreFreezeUntil = 0;
                startEpoch = 0;
                lastTs = 0;
                scoreEl.textContent = String(score);
                updateHpUI();
                updateMaxBallsUI();
            };

            const addScore = (n) => {
                score += n;
                scoreEl.textContent = String(score);
            };

            const loseHp = () => {
                hp -= 1;
                updateHpUI();
                if (hp <= 0) {
                    gameOver = true;
                }
            };

            // ===== Input =====
            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    keyLeft = true;
                } else {
                    if (e.key === 'ArrowRight') {
                        keyRight = true;
                    } else {
                        if (e.key === 'ArrowUp') {
                            keyUp = true;
                        } else {
                            if (e.key === 'ArrowDown') {
                                keyDown = true;
                            } else {
                                if (e.code === 'Space') {
                                    if (gameOver === true) {
                                        resetGame();
                                        return;
                                    }
                                    if (autoFire !== true) {
                                        autoFire = true; // 최초 1회로 자동 발사 시작
                                    }
                                }
                            }
                        }
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft') {
                    keyLeft = false;
                } else {
                    if (e.key === 'ArrowRight') {
                        keyRight = false;
                    } else {
                        if (e.key === 'ArrowUp') {
                            keyUp = false;
                        } else {
                            if (e.key === 'ArrowDown') {
                                keyDown = false;
                            }
                        }
                    }
                }
            });

            restartBtn.addEventListener('click', () => {
                resetGame();
            });

            // ===== Spawners =====
            let nextBlockId = 1;

            const spawnNormalBlocks = (ts) => {
                if (ts < normalSpawnPausedUntil) {
                    return; // 보스 전/후 동결 창에서는 일반 스폰 금지
                }
                const interval = 1600 - Math.min(score * 4, 600);
                if (ts - lastSpawnTime < interval) {
                    return;
                }
                lastSpawnTime = ts;

                const ySpawn = 24;
                const elapsedSec = nowElapsedSec(ts);

                for (let c = 0; c < blockCols; c++) {
                    const spawn = Math.random() < 0.78;
                    if (spawn !== true) {
                        continue;
                    }

                    const x = leftPad + c * cell + blockGap / 2;
                    const needClear = blockSize + minBlockGap;
                    if (hasVerticalClearance(x, blockSize, ySpawn, needClear) !== true) {
                        continue;
                    }

                    const hpAtSpawn = 1 + hpGrowthPerSec * elapsedSec;
                    blocks.push({
                        id: nextBlockId++,
                        x,
                        y: ySpawn,
                        w: blockSize,
                        h: blockSize,
                        hp: hpAtSpawn,
                        isBoss: false
                    });
                }
            };

            const spawnBossIfDue = (ts) => {
                const elapsedSec = nowElapsedSec(ts);

                if (elapsedSec < bossFirstDelaySec) {
                    return;
                }

                // 경과시간 기준 필요한 보스 소환 횟수
                const needCount = Math.floor((elapsedSec - bossFirstDelaySec) / bossSpawnIntervalSec) + 1;
                if (bossSpawnCount >= needCount) {
                    return;
                }

                // 1) 사전 동결 미설정 시, 먼저 일반 스폰을 preBossFreezeSec 만큼 멈춤
                if (bossPreFreezeUntil === 0) {
                    bossPreFreezeUntil = ts + preBossFreezeSec * 1000;
                    normalSpawnPausedUntil = bossPreFreezeUntil; // 이 구간 동안 일반 스폰 중단
                    return;
                }

                // 2) 사전 동결 시간이 아직 남았으면 대기
                if (ts < bossPreFreezeUntil) {
                    return;
                }

                // 3) 자리 확보 완료 → 보스 배치 시도
                const ySpawn = 24;
                const xMin = leftPad;
                const xMax = W - rightPad - bossSize;

                let placed = false;
                let x = xMin + Math.floor(Math.random() * Math.max(1, xMax - xMin + 1));
                const needClear1 = bossSize + minBlockGap;

                for (let tries = 0; tries < 12; tries++) {
                    if (hasVerticalClearance(x, bossSize, ySpawn, needClear1) === true) {
                        placed = true;
                        break;
                    }
                    x = xMin + Math.floor(Math.random() * Math.max(1, xMax - xMin + 1));
                }

                if (placed !== true) {
                    const needClear2 = bossSize + Math.max(2, Math.floor(minBlockGap / 2));
                    for (let tries = 0; tries < 16; tries++) {
                        x = xMin + Math.floor(Math.random() * Math.max(1, xMax - xMin + 1));
                        if (hasVerticalClearance(x, bossSize, ySpawn, needClear2) === true) {
                            placed = true;
                            break;
                        }
                    }
                }

                if (placed !== true) {
                    x = Math.floor((W - bossSize) / 2); // 최후: 중앙 강제 배치
                }

                const hpAtSpawn = (1 + hpGrowthPerSec * elapsedSec) * bossHpMultiplier;
                blocks.push({
                    id: nextBlockId++,
                    x,
                    y: ySpawn,
                    w: bossSize,
                    h: bossSize,
                    hp: hpAtSpawn,
                    isBoss: true
                });

                bossSpawnCount += 1;

                // 4) 보스 등장 후 postBossFreezeSec 동안 일반 스폰 추가 정지
                normalSpawnPausedUntil = ts + postBossFreezeSec * 1000;

                // 5) 다음 보스 준비를 위해 사전 동결 상태 초기화
                bossPreFreezeUntil = 0;
            };

            // ===== Fire Control =====
            const tryAutoFire = (ts) => {
                if (autoFire !== true) {
                    return;
                }
                if (balls.length >= maxBalls) {
                    return;
                }
                if (ts - lastFireTime < fireIntervalMs) {
                    return;
                }
                lastFireTime = ts;

                const vx = Math.cos(aimAngle) * ballSpeed;
                const vy = Math.sin(aimAngle) * ballSpeed;

                balls.push({
                    x: player.x,
                    y: player.y - player.h / 2 - ballRadius - 2,
                    vx,
                    vy,
                    r: ballRadius,
                    dmg: ballDamageBase,
                    hitCD: {}
                });
            };

            // ===== Updates =====
            const updatePlayer = () => {
                if (keyLeft === true) {
                    player.x -= player.speed;
                }
                if (keyRight === true) {
                    player.x += player.speed;
                }
                player.x = clamp(player.x, player.w / 2 + 6, W - player.w / 2 - 6);

                if (keyUp === true) {
                    aimAngle -= 0.03;
                }
                if (keyDown === true) {
                    aimAngle += 0.03;
                }
                aimAngle = clamp(aimAngle, minAngle, maxAngle);
            };

            const updateBalls = () => {
                for (let i = balls.length - 1; i >= 0; i--) {
                    const b = balls[i];

                    b.x += b.vx;
                    b.y += b.vy;

                    if (b.x - b.r < 0) {
                        b.x = b.r;
                        b.vx = Math.abs(b.vx);
                    } else {
                        if (b.x + b.r > W) {
                            b.x = W - b.r;
                            b.vx = -Math.abs(b.vx);
                        }
                    }
                    if (b.y - b.r < 0) {
                        b.y = b.r;
                        b.vy = Math.abs(b.vy);
                    }

                    if (b.y + b.r > H) {
                        balls.splice(i, 1);
                        continue;
                    }

                    const withinX = (b.x > player.x - player.w / 2) && (b.x < player.x + player.w / 2);
                    const withinY = (b.y + b.r > player.y - player.h / 2) && (b.y - b.r < player.y + player.h / 2);
                    if (withinX === true && withinY === true) {
                        balls.splice(i, 1);
                        continue;
                    }
                }
            };

            const updateBlocks = (ts) => {
                const elapsedSec = nowElapsedSec(ts);
                const fallSpeed = blockFallBase + elapsedSec * blockFallGainPerSec;

                // 낙하
                for (let i = blocks.length - 1; i >= 0; i--) {
                    blocks[i].y += fallSpeed;
                }

                // 바닥 처리
                for (let i = blocks.length - 1; i >= 0; i--) {
                    if (blocks[i].y + blocks[i].h >= H - 20) {
                        blocks.splice(i, 1);
                        loseHp();
                    }
                }
            };

            const updateItems = () => {
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i];
                    it.y += itemFallSpeed;

                    const withinX = (it.x + it.w > player.x - player.w / 2) && (it.x < player.x + player.w / 2);
                    const withinY = (it.y + it.h > player.y - player.h / 2) && (it.y < player.y + player.h / 2);
                    if (withinX === true && withinY === true) {
                        if (it.kind === ITEM_TYPE.MAX_BALL) {
                            maxBalls += 1;
                            updateMaxBallsUI();
                        } else {
                            if (it.kind === ITEM_TYPE.DMG_UP) {
                                ballDamageBase += 0.05;
                            }
                        }
                        items.splice(i, 1);
                        continue;
                    }

                    if (it.y > H) {
                        items.splice(i, 1);
                    }
                }
            };

            const checkBallBlockCollisions = (ts) => {
                for (let i = blocks.length - 1; i >= 0; i--) {
                    const bl = blocks[i];
                    for (let j = balls.length - 1; j >= 0; j--) {
                        const b = balls[j];

                        if (b.hitCD[bl.id] && b.hitCD[bl.id] > ts) {
                            continue;
                        }

                        const within =
                            (b.x + b.r > bl.x) &&
                            (b.x - b.r < bl.x + bl.w) &&
                            (b.y + b.r > bl.y) &&
                            (b.y - b.r < bl.y + bl.h);

                        if (within !== true) {
                            continue;
                        }

                        const penLeft = (b.x + b.r) - bl.x;
                        const penRight = (bl.x + bl.w) - (b.x - b.r);
                        const penTop = (b.y + b.r) - bl.y;
                        const penBottom = (bl.y + bl.h) - (b.y - b.r);

                        const minPen = Math.min(penLeft, penRight, penTop, penBottom);

                        if (minPen === penLeft) {
                            b.x -= penLeft;
                            b.vx = -Math.abs(b.vx);
                        } else {
                            if (minPen === penRight) {
                                b.x += penRight;
                                b.vx = Math.abs(b.vx);
                            } else {
                                if (minPen === penTop) {
                                    b.y -= penTop;
                                    b.vy = -Math.abs(b.vy);
                                } else {
                                    b.y += penBottom;
                                    b.vy = Math.abs(b.vy);
                                }
                            }
                        }

                        bl.hp -= b.dmg;

                        if (bl.hp <= 0) {
                            if (bl.isBoss === true) {
                                for (let r = 0; r < bossDropRolls; r++) {
                                    if (Math.random() < dropChance) {
                                        const kind = (Math.random() < 0.5) ? ITEM_TYPE.MAX_BALL : ITEM_TYPE.DMG_UP;
                                        items.push({
                                            x: bl.x + bl.w / 2 - 8 + (Math.random() * 20 - 10),
                                            y: bl.y + bl.h / 2 - 8,
                                            w: 16,
                                            h: 16,
                                            kind
                                        });
                                    }
                                }
                                addScore(50);
                            } else {
                                if (Math.random() < dropChance) {
                                    const kind = (Math.random() < 0.5) ? ITEM_TYPE.MAX_BALL : ITEM_TYPE.DMG_UP;
                                    items.push({
                                        x: bl.x + bl.w / 2 - 8,
                                        y: bl.y,
                                        w: 16,
                                        h: 16,
                                        kind
                                    });
                                }
                                addScore(10);
                            }
                            blocks.splice(i, 1);
                        }

                        b.hitCD[bl.id] = ts + 80;
                        break;
                    }
                }
            };

            // ===== Render =====
            const draw = () => {
                ctx.clearRect(0, 0, W, H);

                // HP색상
                let paddleColor = '#3a86ff';
                if (hp === 2) {
                    paddleColor = '#9b5de5';
                } else {
                    if (hp === 1) {
                        paddleColor = '#f4a261';
                    } else {
                        if (hp <= 0) {
                            paddleColor = '#6b7280';
                        }
                    }
                }

                // 조준선
                ctx.strokeStyle = 'rgba(255,255,255,0.28)';
                ctx.beginPath();
                ctx.moveTo(player.x, player.y - player.h / 2);
                ctx.lineTo(
                    player.x + Math.cos(aimAngle) * 64,
                    player.y + Math.sin(aimAngle) * 64
                );
                ctx.stroke();

                // 플레이어(정사각형)
                ctx.fillStyle = paddleColor;
                ctx.fillRect(player.x - player.w / 2, player.y - player.h / 2, player.w, player.h);

                // 볼
                ctx.fillStyle = '#e63946';
                for (let i = 0; i < balls.length; i++) {
                    const b = balls[i];
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 블록
                for (let i = 0; i < blocks.length; i++) {
                    const bl = blocks[i];
                    if (bl.isBoss === true) {
                        ctx.fillStyle = '#ff006e'; // 보스 색
                        ctx.fillRect(bl.x, bl.y, bl.w, bl.h);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.strokeRect(bl.x + 1, bl.y + 1, bl.w - 2, bl.h - 2);
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px system-ui, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(bl.hp.toFixed(1), bl.x + bl.w / 2, bl.y + bl.h / 2 + 4);
                    } else {
                        const hpVis = Math.max(0, Math.min(bl.hp, 5));
                        const hue = 40 + hpVis * 18;
                        ctx.fillStyle = `hsl(${hue},80%,55%)`;
                        ctx.fillRect(bl.x, bl.y, bl.w, bl.h);
                        ctx.fillStyle = 'rgba(255,255,255,0.12)';
                        ctx.fillRect(bl.x, bl.y, bl.w, 4);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '10px system-ui, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(bl.hp.toFixed(2), bl.x + bl.w / 2, bl.y + bl.h / 2 + 3);
                    }
                }

                // 아이템
                for (let i = 0; i < items.length; i++) {
                    const it = items[i];
                    if (it.kind === ITEM_TYPE.MAX_BALL) {
                        ctx.fillStyle = '#ffd166';
                    } else {
                        ctx.fillStyle = '#4cc9f0';
                    }
                    ctx.fillRect(it.x, it.y, it.w, it.h);
                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.font = '10px system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    const txt = it.kind === ITEM_TYPE.MAX_BALL ? '+' : 'D';
                    ctx.fillText(txt, it.x + it.w / 2, it.y + it.h / 2 + 3);
                }

                if (gameOver === true) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0, 0, W, H);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 28px system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', W / 2, H / 2 - 6);
                    ctx.font = '14px system-ui, sans-serif';
                    ctx.fillText('Space키로 다시 시작', W / 2, H / 2 + 20);
                }
            };

            // ===== Loop =====
            const loop = (ts) => {
                if (startEpoch === 0) {
                    startEpoch = ts;
                }
                if (lastTs === 0) {
                    lastTs = ts;
                }
                lastTs = ts;

                if (gameOver !== true) {
                    updatePlayer();
                    tryAutoFire(ts);
                    updateBalls();
                    updateBlocks(ts);
                    updateItems();
                    checkBallBlockCollisions(ts);
                    spawnNormalBlocks(ts);
                    spawnBossIfDue(ts);
                }
                draw();
                requestAnimationFrame(loop);
            };

            // ===== Start =====
            resetGame();
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>